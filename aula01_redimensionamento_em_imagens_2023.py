# -*- coding: utf-8 -*-
"""aula01_Redimensionamento_em_imagens_2023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hG1v0eedgLwIz4rqU-dlHriqS0AMzEi0
"""

import cv2 # importando a biblioteca OpenCv
import numpy as np
from matplotlib import pyplot as plt
from google.colab.patches import cv2_imshow

# Leitura da imagem com a função imread()
imagem = cv2.imread('lena.png')
#imagem.shape retorna a linha, coluna e canal se quisermos separado declaramos assim como esta abaixo:
print('Linhas em pixels: ', end='')
print(imagem.shape[0]) #Linhas da imagem
print('Colunas em pixels: ', end='')
print(imagem.shape[1]) #Colunas da imagem
print('Qtde de canais: ', end='')
print(imagem.shape[2])

cv2_imshow(imagem) #carrega a imagem na tela

from google.colab.patches import cv2_imshow

imagem = cv2.imread('lena.png')
for y in range(0, imagem.shape[0]): #leitura das linhas
  for x in range(0, imagem.shape[1]): #leitura das colunas
    imagem[y, x] = (255,0,0)

#plt.figure(figsize=(10,10))
#plt.imshow(imagem)

cv2_imshow(imagem)

import cv2
imagem = cv2.imread('lena.png')

#O objetivo agora é saltar a cada 20 pixels ao percorrer as linhas e mais 20 pixels ao percorrer
#as colunas. A cada salto é criado um quadrado azul de 10x10 pixels.

for y in range(0, imagem.shape[0], 20): #percorre linhas
  for x in range(0, imagem.shape[1], 20): #percorre colunas
    imagem[y:y+20, x: x+5] = (100,100,100)#padrao RGB no openCv é BGR

cv2_imshow(imagem)

import cv2

#comando crop

imagem = cv2.imread('lena.png')
recorte = imagem[100:300, 100:300] #f(x,y)
cv2_imshow(recorte)
cv2.waitKey(0)
cv2.destroyAllWindows()

#salvando a nova imagem
import numpy as np
import cv2
cv2.imwrite("recorte.png", recorte) #salva no disco

import numpy as np
import cv2

#comando getRotationMatrix2D

img = cv2.imread('lena.png')
(alt, lar) = img.shape[:2] #captura altura e largura
centro = (lar // 2, alt // 2) #acha o centro
M = cv2.getRotationMatrix2D(centro, 45, 1.0) #rotação em 60 graus #terceiro parametro éo zom im ou zom out
img_rotacionada = cv2.warpAffine(img, M, (lar, alt))
cv2_imshow(img_rotacionada)

print(alt, lar)

import numpy as np
import cv2


#comando imshow
#comando resize

img = cv2.imread('lena.png')
cv2_imshow(img)
largura = img.shape[1]
altura = img.shape[0]
canais = img.shape[2]

#Para reduzir ou aumentar o tamanho da imagem, existe uma função já pronta do OpenCV, trata-se da função ‘resize’.
#Note que é preciso calcular a proporção da altura em relação a largura da nova imagem, caso contrário ela poderá ficar
#distorcida

proporcao = float(altura/largura)
largura_nova = 224 #em pixels
altura_nova = int(largura_nova*proporcao)
tamanho_novo = (largura_nova, altura_nova)

img_redimensionada = cv2.resize(img, tamanho_novo, interpolation = cv2.INTER_AREA)
#cv2.resize precisa de no mínimo esses 3 parametros

#A função ‘rezise’ utiliza uma propriedade aqui definida como cv2.INTER_AREA que é uma especificação
#do cálculo matemático para redimensionar a imagem. Porém, caso a imagem seja redimensionada para um tamanho maior é preciso
#ponderar que ocorrerá perda de qualidade.

cv2_imshow(img_redimensionada)